// Copyright 2021 TNO
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package dpaillier

import (
	"math/big"

	"github.com/TNO-MPC/paillier"
)

// PrivateKeyShare is a share of a Paillier private key. It can be used in cooperation
// with owners of the other private key shares to decrypt messages encrypted with the
// enclosed public key.
type PrivateKeyShare struct {
	paillier.PublicKey

	ParticipantIndex int
	Hi               *big.Int // h(i)
	FactorialOfNPart *big.Int // \nu = n!
	ThetaInv         *big.Int // Cached value for faster decryption
}

// PartiallyDecrypt generates a partial decryption of the ciphertext ct.
// By using this method for all shares of the private key on a given ciphertext and
// using Decrypt on the set of partial decryptions, the plaintext can be recovered.
func (sk *PrivateKeyShare) PartiallyDecrypt(ct *big.Int) *PartialDecryption {
	return &PartialDecryption{
		I:  sk.ParticipantIndex,
		Ci: big.NewInt(0).Exp(ct, sk.Hi, sk.PublicKey.N2),
	}
}

// PartialDecryption is a partial decryption of a ciphertext generated by one share
// of a Paillier private key.
type PartialDecryption struct {
	I  int
	Ci *big.Int
}

// Decrypt combines a full set of partial decryptions of a ciphertext and recovers
// the corresponding plaintext. Any of the private key shares can be used to combine
// the set of partial decryptions. The result is unspecified if an incomplete set of
// partial decryptions is supplied, but the set need not be ordered.
func (sk *PrivateKeyShare) Decrypt(partials []*PartialDecryption) *big.Int {
	// We can't just write this in terms of secret.ShareCombine, since that is written for additive
	// combination (sum li * f(i)) instead of multiplicative (prod ci ^ h(i))
	ctPower := big.NewInt(1)
	li := big.NewInt(1)
	for _, partial := range partials {
		li.Set(sk.FactorialOfNPart)
		for _, other := range partials {
			if partial.I != other.I {
				li.Mul(li, big.NewInt(int64(-other.I))).
					Div(li, big.NewInt(int64(partial.I-other.I)))
			}
		}
		li.Div(li, sk.FactorialOfNPart)
		li.Exp(partial.Ci, li, sk.PublicKey.N2)
		ctPower.Mul(ctPower, li).Mod(ctPower, sk.PublicKey.N2)
	}

	ctPower.
		Sub(ctPower, bigOne).         // L(x) = (x-1) ...
		Div(ctPower, sk.PublicKey.N). //  ... / N
		Mul(ctPower, sk.ThetaInv).    // m = L(ctPower) * ThetaInv ...
		Mod(ctPower, sk.PublicKey.N)  //  ... mod N

	return ctPower
}
